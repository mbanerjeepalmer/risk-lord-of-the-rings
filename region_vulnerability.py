#!/usr/bin/env python3
"""
Risk Region Vulnerability Analysis

Analyzes how vulnerable each region is based on:
1. Total external borders (connections to other regions)
2. Average territory vulnerability within the region
3. Number of border territories
4. Internal connectivity
"""

import csv
from collections import defaultdict
from typing import Dict, List, Set, Tuple


def load_edges_with_regions(filename: str = "edges.csv") -> Tuple[Dict[str, str], Dict[str, List[str]]]:
    """Load territory connections and region mappings from edges.csv"""
    territory_to_region = {}
    connections = defaultdict(set)

    with open(filename, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            region = row['region'].strip()
            territory = row['territory'].strip()
            links_to = row['links_to'].strip()

            # Skip empty rows
            if not territory or not links_to:
                continue

            # Map territory to region
            if region and territory:
                territory_to_region[territory] = region

            # Add bidirectional connection
            connections[territory].add(links_to)
            connections[links_to].add(territory)

    # Convert sets to lists
    return territory_to_region, {t: list(neighbors) for t, neighbors in connections.items()}


def calculate_region_vulnerability(region: str,
                                   territories_in_region: List[str],
                                   territory_to_region: Dict[str, str],
                                   connections: Dict[str, List[str]]) -> Dict:
    """Calculate comprehensive vulnerability metrics for a region"""

    # Count external borders (connections to territories in other regions)
    external_borders = 0
    border_territories = set()
    internal_borders = 0

    # Track which other regions this region borders
    bordering_regions = set()

    for territory in territories_in_region:
        if territory not in connections:
            continue

        has_external_border = False
        for neighbor in connections[territory]:
            neighbor_region = territory_to_region.get(neighbor, "unknown")

            if neighbor_region != region:
                external_borders += 1
                has_external_border = True
                if neighbor_region != "unknown":
                    bordering_regions.add(neighbor_region)
            else:
                internal_borders += 1

        if has_external_border:
            border_territories.add(territory)

    # Calculate territory-level metrics
    territory_border_counts = []
    total_vulnerability_score = 0

    for territory in territories_in_region:
        if territory in connections:
            border_count = len(connections[territory])
            territory_border_counts.append(border_count)

            # Calculate vulnerability score like in territory analysis
            second_degree = set()
            for neighbor in connections[territory]:
                if neighbor in connections:
                    for second_neighbor in connections[neighbor]:
                        if second_neighbor != territory:
                            second_degree.add(second_neighbor)

            vuln_score = border_count + (len(second_degree) * 0.2)
            total_vulnerability_score += vuln_score

    # Calculate averages
    num_territories = len(territories_in_region)
    avg_borders_per_territory = sum(territory_border_counts) / num_territories if num_territories > 0 else 0
    avg_vulnerability_score = total_vulnerability_score / num_territories if num_territories > 0 else 0

    # Calculate strategic metrics
    border_territory_ratio = len(border_territories) / num_territories if num_territories > 0 else 0

    # Overall region vulnerability score
    # Factors:
    # - External borders (most important)
    # - Average territory vulnerability
    # - Percentage of territories that are border territories
    # - Number of neighboring regions (more neighbors = more threats)
    region_vuln_score = (
        external_borders * 1.0 +
        avg_vulnerability_score * 0.5 +
        border_territory_ratio * 10 +
        len(bordering_regions) * 0.5
    )

    return {
        'region': region,
        'num_territories': num_territories,
        'external_borders': external_borders,
        'internal_borders': internal_borders,
        'border_territories': sorted(border_territories),
        'num_border_territories': len(border_territories),
        'border_territory_ratio': border_territory_ratio,
        'avg_borders_per_territory': avg_borders_per_territory,
        'avg_vulnerability_score': avg_vulnerability_score,
        'bordering_regions': sorted(bordering_regions),
        'num_bordering_regions': len(bordering_regions),
        'region_vulnerability_score': region_vuln_score
    }


def categorize_region_vulnerability(score: float) -> str:
    """Categorize region vulnerability based on score"""
    if score >= 20:
        return "CRITICAL"
    elif score >= 15:
        return "HIGH"
    elif score >= 10:
        return "MEDIUM"
    else:
        return "LOW"


def main():
    print("=" * 90)
    print("RISK REGION VULNERABILITY ANALYSIS")
    print("=" * 90)
    print()

    # Load data
    territory_to_region, connections = load_edges_with_regions("edges.csv")

    # Group territories by region
    regions = defaultdict(list)
    for territory, region in territory_to_region.items():
        if region:  # Skip territories without region
            regions[region].append(territory)

    # Calculate vulnerability for each region
    region_data = []
    for region, territories in regions.items():
        vuln_data = calculate_region_vulnerability(
            region, territories, territory_to_region, connections
        )
        vuln_data['category'] = categorize_region_vulnerability(
            vuln_data['region_vulnerability_score']
        )
        region_data.append(vuln_data)

    # Sort by vulnerability score (descending)
    region_data.sort(key=lambda x: x['region_vulnerability_score'], reverse=True)

    # Display rankings
    print("REGION VULNERABILITY RANKINGS")
    print("-" * 90)
    print(f"{'Rank':<6} {'Region':<15} {'Score':<8} {'Risk':<10} {'Ext.Borders':<12} {'Territories':<12}")
    print("-" * 90)

    for i, data in enumerate(region_data, 1):
        print(f"{i:<6} {data['region']:<15} {data['region_vulnerability_score']:<8.1f} "
              f"{data['category']:<10} {data['external_borders']:<12} {data['num_territories']:<12}")

    print()
    print("=" * 90)
    print("DETAILED REGION ANALYSIS")
    print("=" * 90)

    for i, data in enumerate(region_data, 1):
        print(f"\n{i}. {data['region'].upper()}")
        print(f"   Overall Vulnerability Score: {data['region_vulnerability_score']:.1f}")
        print(f"   Risk Level: {data['category']}")
        print(f"   ")
        print(f"   Territory Metrics:")
        print(f"     - Total territories: {data['num_territories']}")
        print(f"     - Border territories: {data['num_border_territories']} "
              f"({data['border_territory_ratio']*100:.1f}%)")
        print(f"     - Average borders per territory: {data['avg_borders_per_territory']:.1f}")
        print(f"   ")
        print(f"   Border Metrics:")
        print(f"     - External borders (to other regions): {data['external_borders']}")
        print(f"     - Internal borders (within region): {data['internal_borders']}")
        print(f"     - Neighboring regions: {data['num_bordering_regions']}")
        print(f"   ")
        print(f"   Bordering Regions: {', '.join(data['bordering_regions']) if data['bordering_regions'] else 'None'}")
        print(f"   Border Territories: {', '.join(data['border_territories'])}")

    print()
    print("=" * 90)
    print("STRATEGIC SUMMARY")
    print("=" * 90)

    # Group by category
    categories = defaultdict(list)
    for data in region_data:
        categories[data['category']].append(data['region'])

    for category in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
        if category in categories:
            print(f"\n{category} VULNERABILITY ({len(categories[category])} regions):")
            print(f"  {', '.join(categories[category])}")

    print()
    print("=" * 90)
    print("KEY INSIGHTS")
    print("=" * 90)

    # Find most/least vulnerable
    most_vulnerable = region_data[0]
    least_vulnerable = region_data[-1]

    print(f"\nMost Vulnerable Region: {most_vulnerable['region'].upper()}")
    print(f"  - {most_vulnerable['external_borders']} external borders")
    print(f"  - {most_vulnerable['num_border_territories']}/{most_vulnerable['num_territories']} "
          f"territories are border territories")
    print(f"  - Borders {most_vulnerable['num_bordering_regions']} other regions")

    print(f"\nMost Secure Region: {least_vulnerable['region'].upper()}")
    print(f"  - {least_vulnerable['external_borders']} external borders")
    print(f"  - {least_vulnerable['num_border_territories']}/{least_vulnerable['num_territories']} "
          f"territories are border territories")
    print(f"  - Borders {least_vulnerable['num_bordering_regions']} other regions")

    # Find region with most neighbors
    most_neighbors = max(region_data, key=lambda x: x['num_bordering_regions'])
    print(f"\nMost Exposed Region (most neighboring regions): {most_neighbors['region'].upper()}")
    print(f"  - Borders {most_neighbors['num_bordering_regions']} regions: "
          f"{', '.join(most_neighbors['bordering_regions'])}")

    print()
    print("=" * 90)


if __name__ == "__main__":
    main()
