#!/usr/bin/env python3
"""
Risk Territory Vulnerability Analysis

This script analyzes how vulnerable each territory is based on:
1. Number of connections (borders) - more borders = more attack vectors
2. Strategic position - territories with many connections are harder to defend
"""

import csv
from collections import defaultdict
from typing import Dict, List, Tuple


def load_edges(filename: str = "edges.csv") -> Dict[str, List[str]]:
    """Load territory connections from edges.csv"""
    connections = defaultdict(set)

    with open(filename, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            territory = row['territory'].strip()
            links_to = row['links_to'].strip()

            # Skip empty rows
            if not territory or not links_to:
                continue

            # Add bidirectional connection
            connections[territory].add(links_to)
            connections[links_to].add(territory)

    # Convert sets to lists for consistency
    return {t: list(neighbors) for t, neighbors in connections.items()}


def calculate_vulnerability_score(territory: str, connections: Dict[str, List[str]]) -> float:
    """
    Calculate vulnerability score for a territory.

    Higher score = more vulnerable
    Based on:
    - Number of direct borders (primary factor)
    - Number of neighbors' neighbors (secondary threat)
    """
    if territory not in connections:
        return 0.0

    direct_borders = len(connections[territory])

    # Count second-degree connections (neighbors of neighbors)
    second_degree = set()
    for neighbor in connections[territory]:
        if neighbor in connections:
            for second_neighbor in connections[neighbor]:
                if second_neighbor != territory:
                    second_degree.add(second_neighbor)

    # Vulnerability score: weighted combination
    # Direct borders are most important (weight 1.0)
    # Second-degree connections show regional pressure (weight 0.2)
    vulnerability = direct_borders + (len(second_degree) * 0.2)

    return vulnerability


def categorize_vulnerability(border_count: int) -> str:
    """Categorize vulnerability based on number of borders"""
    if border_count <= 2:
        return "LOW"
    elif border_count <= 4:
        return "MEDIUM"
    elif border_count <= 6:
        return "HIGH"
    else:
        return "CRITICAL"


def main():
    print("=" * 80)
    print("RISK TERRITORY VULNERABILITY ANALYSIS")
    print("=" * 80)
    print()

    # Load data
    connections = load_edges("edges.csv")

    # Calculate vulnerability for each territory
    vulnerability_data = []
    for territory in sorted(connections.keys()):
        border_count = len(connections[territory])
        vuln_score = calculate_vulnerability_score(territory, connections)
        category = categorize_vulnerability(border_count)

        vulnerability_data.append({
            'territory': territory,
            'borders': border_count,
            'vulnerability_score': vuln_score,
            'category': category,
            'neighbors': connections[territory]
        })

    # Sort by vulnerability score (descending)
    vulnerability_data.sort(key=lambda x: x['vulnerability_score'], reverse=True)

    # Display results
    print("MOST VULNERABLE TERRITORIES")
    print("-" * 80)
    print(f"{'Territory':<20} {'Borders':<10} {'Score':<10} {'Risk Level':<12}")
    print("-" * 80)

    for i, data in enumerate(vulnerability_data[:20], 1):
        print(f"{data['territory']:<20} {data['borders']:<10} {data['vulnerability_score']:<10.1f} {data['category']:<12}")

    print()
    print("=" * 80)
    print("VULNERABILITY BREAKDOWN BY CATEGORY")
    print("=" * 80)

    categories = defaultdict(list)
    for data in vulnerability_data:
        categories[data['category']].append(data['territory'])

    for category in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
        if category in categories:
            count = len(categories[category])
            print(f"\n{category} RISK ({count} territories):")
            print(f"  {', '.join(sorted(categories[category]))}")

    print()
    print("=" * 80)
    print("MOST SECURE TERRITORIES (Fewest borders)")
    print("-" * 80)

    # Show least vulnerable
    least_vulnerable = sorted(vulnerability_data, key=lambda x: x['borders'])[:10]
    for data in least_vulnerable:
        neighbors_str = ", ".join(sorted(data['neighbors']))
        print(f"{data['territory']:<20} ({data['borders']} borders): {neighbors_str}")

    print()
    print("=" * 80)
    print("DETAILED ANALYSIS OF MOST VULNERABLE")
    print("=" * 80)

    # Show top 5 most vulnerable with neighbor details
    for i, data in enumerate(vulnerability_data[:5], 1):
        print(f"\n{i}. {data['territory'].upper()}")
        print(f"   Borders: {data['borders']}")
        print(f"   Vulnerability Score: {data['vulnerability_score']:.1f}")
        print(f"   Risk Level: {data['category']}")
        print(f"   Neighbors: {', '.join(sorted(data['neighbors']))}")

    print()
    print("=" * 80)

    # Summary statistics
    total = len(vulnerability_data)
    avg_borders = sum(d['borders'] for d in vulnerability_data) / total
    max_borders = max(d['borders'] for d in vulnerability_data)
    min_borders = min(d['borders'] for d in vulnerability_data)

    print("SUMMARY STATISTICS")
    print("-" * 80)
    print(f"Total territories: {total}")
    print(f"Average borders per territory: {avg_borders:.1f}")
    print(f"Maximum borders: {max_borders}")
    print(f"Minimum borders: {min_borders}")
    print("=" * 80)


if __name__ == "__main__":
    main()
