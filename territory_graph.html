<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory Graph Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0f1419;
            color: #e6edf3;
            overflow: hidden;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 15px;
            z-index: 100;
            max-width: 300px;
        }

        #controls h2 {
            color: #58a6ff;
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        #status {
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        #status.loading {
            background: rgba(88, 166, 255, 0.1);
            color: #58a6ff;
        }

        #status.error {
            background: rgba(248, 81, 73, 0.1);
            color: #f85149;
        }

        #status.success {
            background: rgba(63, 185, 80, 0.1);
            color: #3fb950;
        }

        .file-upload {
            margin-top: 10px;
            padding: 10px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
        }

        .file-upload label {
            display: block;
            color: #8b949e;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .file-upload input[type="file"] {
            display: block;
            width: 100%;
            padding: 8px;
            background: #0d1117;
            color: #e6edf3;
            border: 1px solid #30363d;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .view-toggle {
            margin-top: 15px;
            padding: 10px;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
        }

        .view-toggle label {
            display: block;
            color: #8b949e;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .toggle-buttons {
            display: flex;
            gap: 8px;
        }

        .toggle-button {
            flex: 1;
            padding: 8px;
            background: #0d1117;
            color: #8b949e;
            border: 1px solid #30363d;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            text-align: center;
            transition: all 0.2s;
        }

        .toggle-button:hover {
            background: #161b22;
            border-color: #58a6ff;
        }

        .toggle-button.active {
            background: #58a6ff;
            color: #fff;
            border-color: #58a6ff;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        .node-label {
            pointer-events: none;
            user-select: none;
        }

        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 15px;
            z-index: 100;
        }

        #legend h3 {
            color: #58a6ff;
            font-size: 1em;
            margin-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 0.85em;
        }

        .legend-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid #fff;
        }

        .legend-text {
            color: #8b949e;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h2>Territory Graph</h2>
        <div id="status" class="loading">Attempting to load edges.csv...</div>
        <div class="file-upload">
            <label for="csvFile">Upload your own CSV:</label>
            <input type="file" id="csvFile" accept=".csv">
        </div>
        <div class="view-toggle">
            <label>View Mode:</label>
            <div class="toggle-buttons">
                <div class="toggle-button active" data-view="territories">Territories</div>
                <div class="toggle-button" data-view="regions">Regions</div>
            </div>
        </div>
    </div>

    <div id="legend">
        <h3>Node Size</h3>
        <div class="legend-item">
            <div class="legend-circle" style="width: 12px; height: 12px;"></div>
            <div class="legend-text">1-2 connections</div>
        </div>
        <div class="legend-item">
            <div class="legend-circle" style="width: 20px; height: 20px;"></div>
            <div class="legend-text">3-4 connections</div>
        </div>
        <div class="legend-item">
            <div class="legend-circle" style="width: 28px; height: 28px;"></div>
            <div class="legend-text">5+ connections</div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        });

        // Region colors
        const regionColors = {
            'arnor': '#ff4444',
            'gondor': '#8b4513',
            'rhovanion': '#ff8c00',
            'rohan': '#4169e1',
            'eriador': '#ffd700',
            'mordor': '#808080',
            'haradwaith': '#d2b48c',
            'mirkwood': '#228b22',
            'rhûn': '#9370db'
        };

        let nodes = [];
        let edges = [];
        let regionNodes = [];
        let regionEdges = [];
        let dragging = null;
        let offsetX = 0;
        let offsetY = 0;
        let viewMode = 'territories'; // 'territories' or 'regions'

        // Parse CSV data
        function parseCSV(csvData) {
            const lines = csvData.trim().split('\n').slice(1); // Skip header
            const territoryMap = new Map();
            const edgeSet = new Set();
            const regionMap = new Map();
            const territoryConnections = new Map(); // Track all connections per territory

            lines.forEach(line => {
                const [region, territory, linksTo] = line.split(',').map(s => s.trim());
                if (!territory || !linksTo) return;

                const normalizedRegion = region.toLowerCase();

                if (!territoryMap.has(territory)) {
                    territoryMap.set(territory, new Set());
                    regionMap.set(territory, normalizedRegion);
                    territoryConnections.set(territory, { inter: 0, intra: 0 });
                }

                territoryMap.get(territory).add(linksTo);

                // Create bidirectional edges (avoid duplicates)
                const edgeKey = [territory, linksTo].sort().join('|');
                edgeSet.add(edgeKey);
            });

            // Calculate inter/intra region connections
            territoryMap.forEach((connections, territory) => {
                const territoryRegion = regionMap.get(territory);
                let inter = 0;
                let intra = 0;

                connections.forEach(connectedTerritory => {
                    const connectedRegion = regionMap.get(connectedTerritory);
                    if (connectedRegion === territoryRegion) {
                        intra++;
                    } else {
                        inter++;
                    }
                });

                territoryConnections.set(territory, { inter, intra });
            });

            // Create nodes
            nodes = Array.from(territoryMap.entries()).map(([name, connections]) => ({
                name,
                connections: connections.size,
                inter: territoryConnections.get(name).inter,
                intra: territoryConnections.get(name).intra,
                region: regionMap.get(name) || 'unknown',
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: 0,
                vy: 0
            }));

            // Create edges with region info
            edges = Array.from(edgeSet).map(key => {
                const [source, target] = key.split('|');
                return {
                    source,
                    target,
                    sourceRegion: regionMap.get(source),
                    targetRegion: regionMap.get(target)
                };
            });

            // Create region view
            createRegionView(regionMap, territoryMap);

            statusDiv.className = 'success';
            statusDiv.textContent = `✓ Loaded ${nodes.length} territories with ${edges.length} connections`;
        }

        // Create aggregated region view
        function createRegionView(regionMap, territoryMap) {
            const regionConnectionMap = new Map();
            const regionEdgeSet = new Set();

            // Count connections between regions
            edges.forEach(edge => {
                const sourceRegion = regionMap.get(edge.source);
                const targetRegion = regionMap.get(edge.target);

                if (!regionConnectionMap.has(sourceRegion)) {
                    regionConnectionMap.set(sourceRegion, new Map());
                }
                if (!regionConnectionMap.has(targetRegion)) {
                    regionConnectionMap.set(targetRegion, new Map());
                }

                // Track inter-region connections
                if (sourceRegion !== targetRegion) {
                    const edgeKey = [sourceRegion, targetRegion].sort().join('|');
                    regionEdgeSet.add(edgeKey);
                }
            });

            // Count total connections per region (including internal)
            const regionTotalConnections = new Map();
            edges.forEach(edge => {
                const sourceRegion = regionMap.get(edge.source);
                const targetRegion = regionMap.get(edge.target);

                regionTotalConnections.set(sourceRegion, (regionTotalConnections.get(sourceRegion) || 0) + 1);
                regionTotalConnections.set(targetRegion, (regionTotalConnections.get(targetRegion) || 0) + 1);
            });

            // Create region nodes
            regionNodes = Array.from(new Set(regionMap.values())).map(region => {
                const totalConnections = regionTotalConnections.get(region) || 0;
                const interRegionConnections = Array.from(regionEdgeSet)
                    .filter(key => key.includes(region)).length;

                return {
                    name: region,
                    connections: totalConnections,
                    inter: interRegionConnections,
                    intra: totalConnections - interRegionConnections,
                    region: region,
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: 0,
                    vy: 0
                };
            });

            // Create region edges
            regionEdges = Array.from(regionEdgeSet).map(key => {
                const [source, target] = key.split('|');
                return {
                    source,
                    target,
                    sourceRegion: source,
                    targetRegion: target
                };
            });
        }

        // Physics simulation
        function simulate() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const repulsion = 3000;
            const attraction = 0.001;
            const damping = 0.9;

            const currentNodes = viewMode === 'territories' ? nodes : regionNodes;
            const currentEdges = viewMode === 'territories' ? edges : regionEdges;

            // Apply forces
            currentNodes.forEach(node => {
                if (node === dragging) return;

                // Repulsion from other nodes
                currentNodes.forEach(other => {
                    if (node === other) return;
                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = repulsion / (dist * dist);
                    node.vx += (dx / dist) * force;
                    node.vy += (dy / dist) * force;
                });

                // Attraction along edges
                currentEdges.forEach(edge => {
                    let other = null;
                    if (edge.source === node.name) {
                        other = currentNodes.find(n => n.name === edge.target);
                    } else if (edge.target === node.name) {
                        other = currentNodes.find(n => n.name === edge.source);
                    }

                    if (other) {
                        const dx = other.x - node.x;
                        const dy = other.y - node.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        node.vx += dx * attraction;
                        node.vy += dy * attraction;
                    }
                });

                // Gentle pull towards center
                node.vx += (centerX - node.x) * 0.0001;
                node.vy += (centerY - node.y) * 0.0001;

                // Apply velocity with damping
                node.vx *= damping;
                node.vy *= damping;
                node.x += node.vx;
                node.y += node.vy;

                // Keep in bounds (soft constraint)
                const margin = 100;
                if (node.x < margin) node.vx += 1;
                if (node.x > canvas.width - margin) node.vx -= 1;
                if (node.y < margin) node.vy += 1;
                if (node.y > canvas.height - margin) node.vy -= 1;
            });
        }

        // Draw split-colored edge
        function drawSplitEdge(x1, y1, x2, y2, color1, color2) {
            // Calculate perpendicular offset for split effect
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx * dx + dy * dy);
            const perpX = -dy / len;
            const perpY = dx / len;
            const offset = 1.5; // Offset for gap between lines
            const lineWidth = 1.5; // Thinner lines

            // Draw first half (color1 side)
            ctx.strokeStyle = color1;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(x1 + perpX * offset, y1 + perpY * offset);
            ctx.lineTo(x2 + perpX * offset, y2 + perpY * offset);
            ctx.stroke();

            // Draw second half (color2 side)
            ctx.strokeStyle = color2;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(x1 - perpX * offset, y1 - perpY * offset);
            ctx.lineTo(x2 - perpX * offset, y2 - perpY * offset);
            ctx.stroke();
        }

        // Draw everything
        function draw() {
            ctx.fillStyle = '#0f1419';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const currentNodes = viewMode === 'territories' ? nodes : regionNodes;
            const currentEdges = viewMode === 'territories' ? edges : regionEdges;

            // Draw edges with split colors
            currentEdges.forEach(edge => {
                const source = currentNodes.find(n => n.name === edge.source);
                const target = currentNodes.find(n => n.name === edge.target);
                if (source && target) {
                    const color1 = regionColors[edge.sourceRegion] || '#58a6ff';
                    const color2 = regionColors[edge.targetRegion] || '#58a6ff';
                    drawSplitEdge(source.x, source.y, target.x, target.y, color1, color2);
                }
            });

            // Draw nodes
            currentNodes.forEach(node => {
                const radius = 18; // Fixed size for all nodes
                const color = regionColors[node.region] || '#58a6ff';

                // Node circle
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Node border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Connection count (main number)
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 13px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.connections, node.x, node.y);

                // Enable shadow for text below node
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;

                // Territory/region name
                ctx.fillStyle = '#e6edf3';
                ctx.font = '12px sans-serif';
                ctx.fillText(node.name, node.x, node.y + radius + 15);

                // Inter/intra breakdown (below territory name)
                ctx.font = '11px sans-serif';

                // Draw inter number (white)
                const breakdownText = `${node.inter}/`;
                const interWidth = ctx.measureText(breakdownText).width;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(breakdownText, node.x - interWidth / 2, node.y + radius + 28);

                // Draw intra number (region color)
                const intraText = `${node.intra}`;
                const totalWidth = ctx.measureText(`${node.inter}/${node.intra}`).width;
                ctx.fillStyle = color;
                ctx.fillText(intraText, node.x + totalWidth / 2 - ctx.measureText(intraText).width / 2, node.y + radius + 28);

                // Disable shadow for subsequent drawing
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            });
        }

        // Animation loop
        let animationId;
        function animate() {
            simulate();
            draw();
            animationId = requestAnimationFrame(animate);
        }

        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const currentNodes = viewMode === 'territories' ? nodes : regionNodes;

            // Find clicked node
            for (let node of currentNodes) {
                const radius = 18; // Fixed size
                const dist = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
                if (dist < radius) {
                    dragging = node;
                    offsetX = x - node.x;
                    offsetY = y - node.y;
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (dragging) {
                const rect = canvas.getBoundingClientRect();
                dragging.x = e.clientX - rect.left - offsetX;
                dragging.y = e.clientY - rect.top - offsetY;
                dragging.vx = 0;
                dragging.vy = 0;
            }
        });

        canvas.addEventListener('mouseup', () => {
            dragging = null;
        });

        // View toggle
        document.querySelectorAll('.toggle-button').forEach(button => {
            button.addEventListener('click', () => {
                const newView = button.getAttribute('data-view');
                if (newView !== viewMode) {
                    viewMode = newView;
                    dragging = null;

                    // Update active state
                    document.querySelectorAll('.toggle-button').forEach(b => {
                        b.classList.remove('active');
                    });
                    button.classList.add('active');
                }
            });
        });

        // Load CSV from server
        async function loadFromServer() {
            try {
                const response = await fetch('edges.csv');
                if (!response.ok) throw new Error('File not found');
                const csvData = await response.text();
                parseCSV(csvData);
                animate();
            } catch (error) {
                statusDiv.className = 'error';
                statusDiv.textContent = 'Could not load edges.csv from server. Please upload your own CSV file.';
            }
        }

        // Load CSV from file upload
        document.getElementById('csvFile').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                const file = e.target.files[0];
                const reader = new FileReader();

                statusDiv.className = 'loading';
                statusDiv.textContent = `Loading ${file.name}...`;

                reader.onload = (event) => {
                    try {
                        parseCSV(event.target.result);
                        if (animationId) {
                            cancelAnimationFrame(animationId);
                        }
                        animate();
                    } catch (error) {
                        statusDiv.className = 'error';
                        statusDiv.textContent = `Error parsing CSV: ${error.message}`;
                    }
                };

                reader.onerror = () => {
                    statusDiv.className = 'error';
                    statusDiv.textContent = 'Error reading file';
                };

                reader.readAsText(file);
            }
        });

        // Initial load
        loadFromServer();
    </script>
</body>
</html>
